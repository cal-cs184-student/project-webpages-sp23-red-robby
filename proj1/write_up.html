<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Isolde Fang, Jakob Sorensen">

<title>Project 1: Rasterizer</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="write_up_files/libs/clipboard/clipboard.min.js"></script>
<script src="write_up_files/libs/quarto-html/quarto.js"></script>
<script src="write_up_files/libs/quarto-html/popper.min.js"></script>
<script src="write_up_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="write_up_files/libs/quarto-html/anchor.min.js"></script>
<link href="write_up_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="write_up_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="write_up_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="write_up_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="write_up_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Project 1: Rasterizer</h1>
<p class="subtitle lead">CS 184: Computer Graphics and Imaging, Spring 2023</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Isolde Fang, Jakob Sorensen </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="project-1-rasterizer" class="level1">
<h1>Project 1: Rasterizer</h1>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>In this assignment, we implemented a rasterizer capable of rendering simplified SVG (Scalable Vector Graphics) files. This included rendering triangles in various forms (single-colored, interpolated, and textured), a generic sampling approach capable of supersampling at arbitrary rates via nearest, bilinear, and summed area tables sampling methods, and level sampling with mipmaps. At a higher level, we compared different approaches of minimizing aliases in our renderings. Progressing from single-colored triangles to sophisticated mipmap-based texturing techniques and observing the differences between the approaches taught us a lot about the rasterization process and improved our appreciation of it. Most of all, we enjoyed doing research on and implementing sampling via Summed Area Tables. Overall, we found the process rewarding, as unlike most programming assignments, this gave us the immediate satisfaction of an appealing image on successful completion of a step.</p>
</section>
<section id="section-i-rasterization" class="level2">
<h2 class="anchored" data-anchor-id="section-i-rasterization">Section I: Rasterization</h2>
<section id="part-1-rasterizing-single-color-triangles" class="level3">
<h3 class="anchored" data-anchor-id="part-1-rasterizing-single-color-triangles">Part 1: Rasterizing single-color triangles</h3>
<section id="algorithm-and-data-structures" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-and-data-structures">Algorithm and Data Structures</h4>
<p>Our algorithm for rasterizing a triangle begins with determining <em>which</em> pixels to sample. Attempting to adhere to the Single Responsibility Principle (a pattern you’ll notice throughout), we abstracted this into a minimal class, <code>BoundingBox</code>. Once the bounds are obtained, we traverse each point within. For each, we check if it’s <em>inside</em> or <em>on the edge</em> of the triangle. We use the three-line test for this computation.</p>
<p>If the check passes, we set the framebuffer entry associated with the pixel to the specified color parameter. Here again we adhere to the Single Responsibility Principle in two ways. First, the act of sampling a pixel has been abstracted into the <code>PixelSampler</code> class. This is a <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)"><em>closure</em></a> that is created before we traverse the points and contains the information necessary to sample all points witin a pixel correctly. It’s behavior importantly differs depending on the sampling rate. It will be explained in greater detail later.</p>
<p>Second, we recognized that rasterizing single-color triangles differs from the more complicated cases only in how <em>the color is obtained</em>. For this reason, we abstracted the main implementation <em>for all triangles</em> into a private method, <code>rasterize_triangle()</code>. It’s signature is below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>ColorFunction ColorFn<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="va">rasterize_triangle_</span><span class="op">(</span><span class="at">const</span> detail::Triangle<span class="op"> &amp;</span>triangle<span class="op">,</span> ColorFn <span class="op">&amp;&amp;</span>color_fn<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That is, the implementation is identical for each triangle type <em>except the color computation</em>, which is a function provided as a parameter. Note that <code>ColorFunction</code> is a C++20 concept defined as follows.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ColorFn<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> ColorFunction <span class="op">=</span> <span class="bu">std::</span>is_invocable_r_v<span class="op">&lt;</span>Color<span class="op">,</span> ColorFn<span class="op">,</span> <span class="dt">float</span><span class="op">,</span> <span class="dt">float</span><span class="op">&gt;;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For single-color triangles, we simply pass a lambda that always returns a single color, seen below. These functions become more interesting in later parts.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> RasterizerImp<span class="op">::</span>rasterize_triangle<span class="op">(</span><span class="dt">float</span> x0<span class="op">,</span> <span class="dt">float</span> y0<span class="op">,</span> <span class="dt">float</span> x1<span class="op">,</span> <span class="dt">float</span> y1<span class="op">,</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                                       <span class="dt">float</span> x2<span class="op">,</span> <span class="dt">float</span> y2<span class="op">,</span> Color color<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> detail::Triangle<span class="op"> </span>triangle<span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      detail::Pointf<span class="op">{</span>x0<span class="op">,</span> y0<span class="op">},</span> detail::Pointf<span class="op">{</span>x1<span class="op">,</span> y1<span class="op">},</span> detail::Pointf<span class="op">{</span>x2<span class="op">,</span> y2<span class="op">}};</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">rasterize_triangle_</span><span class="op">(</span>triangle<span class="op">,</span> <span class="op">[</span>color<span class="op">](</span><span class="kw">auto</span><span class="op">,</span> <span class="kw">auto</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> color<span class="op">;</span> <span class="op">});</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="rendering-result" class="level4">
<h4 class="anchored" data-anchor-id="rendering-result">Rendering Result</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task01_zoom.png" class="img-fluid figure-img" style="width:80.0%"></p>
<p></p><figcaption class="figure-caption">A render of basic single-colored triangles with the default settings from <code>basic/test4.svg</code> Note the presence of significant <em>jaggies</em> at this sampling rate.</figcaption><p></p>
</figure>
</div>
</section>
</section>
<section id="extra-credit-an-optimization-attempt" class="level3">
<h3 class="anchored" data-anchor-id="extra-credit-an-optimization-attempt">Extra Credit: An Optimization Attempt</h3>
<p>We noted that when a triangle is sampled, each element in the sample framebuffer is only modified <em>once</em>. This means we can do this operation in parallel without risk of data races. We attempted this using the parallel version of <code>std::for_each</code> from <code>&lt;algorithm&gt;</code> instead of manual loops. The format of this is seen below.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>for_each<span class="op">(</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>execution<span class="bu">::</span>par<span class="op">,</span> <span class="bu">std::</span>begin<span class="op">(</span>rows<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>rows<span class="op">),</span> <span class="op">[&amp;](</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> <span class="co">/* bounds checking */</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a> <span class="bu">std::</span>for_each<span class="op">(</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>execution<span class="bu">::</span>par<span class="op">,</span> <span class="bu">std::</span>begin<span class="op">(</span>cols<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>cols<span class="op">),</span> <span class="op">[&amp;](</span><span class="dt">int</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* bounds checking */</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* sample the pixel associated with (i, j) */</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">});</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">});</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However, the improvements observed were minimal. Testing on the <code>svg/hardcore</code> images, we observed an average of <code>0.0173571s</code> per triangle with the optimization and an average of <code>0.0177227s</code> per triangle without the optimization, i.e., a measly ~2% improvement – though it was observed consistently. Note that this average includes all sampling rates (1, 4, 9, 16), which are equally weighed.</p>
</section>
<section id="part-2-antialiasing-triangles" class="level3">
<h3 class="anchored" data-anchor-id="part-2-antialiasing-triangles">Part 2: Antialiasing triangles</h3>
<section id="algorithm-and-data-structures-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-and-data-structures-1">Algorithm and Data Structures</h4>
<p>In this step, the sample buffer grows in complexity. It no longer maintains a one-to-one correspondence with the frame buffer, but instead contains a variable number of colors for each pixel (dependent on the sampling rate). For this reason, we abstracted the sample buffer into its own class, <code>ColorBuffer</code>. This was done primarily to avoid duplicate code (i.e., the arithmetic to calculate the correct index) and recalculating the number of columns in the frame buffer.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ColorBuffer <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="at">const</span> Color <span class="op">&amp;</span>color<span class="op">(</span><span class="bu">std::</span>size_t<span class="op"> </span>x<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>y<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> set_color<span class="op">(</span><span class="bu">std::</span>size_t<span class="op"> </span>x<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>y<span class="op">,</span> Color c<span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> fill<span class="op">(</span>Color c<span class="op">);</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> resize<span class="op">(</span><span class="bu">std::</span>size_t<span class="op"> </span>width<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>height<span class="op">);</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>Color<span class="op">&gt;</span> <span class="va">buf_</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span><span class="va">cols_</span><span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this, the sampling procedure proceeds as follows. We first translate the provided coordinates of the triangle to their sample buffer equivalents. This is done by multiplying each coordinate by the square root of the sample rate. We then use this as a starting point to obtain all of the sampling points. The algorithm is identical to the one used in the previous section, and is found in <code>PixelSampler</code>, which will now be described.</p>
<p><code>PixelSampler</code> is a closure, as mentioned previously, that stores all information needed to obtain the color of a point given the color buffer and position in the sample buffer. It importantly contains an <em>initial offset</em> and <em>step</em>. The algorithm starts at the initial offset (offset in both dimension) and proceeds in steps of the stored size, moving row by row until all sample points have been visited for the pixel. So this task only differs from the previous in the initial offset and step provided. The relation to the sampling rate is given as follows:</p>
<p><span class="math display">\[\text{Initial Offset} = \frac{1}{2\sqrt{\text{Sample Rate}}}\]</span> <span class="math display">\[\text{Step} = \frac{1}{\sqrt{\text{Sample Rate}}}\]</span></p>
<p><code>PixelSampler</code> is defined below.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>ColorFunction ColorFn<span class="op">&gt;</span> <span class="kw">class</span> PixelSampler <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  PixelSampler<span class="op">(</span><span class="at">const</span> Triangle <span class="op">&amp;</span>t<span class="op">,</span> ColorFn <span class="op">&amp;&amp;</span>color_fn<span class="op">,</span> <span class="dt">float</span> init_offset<span class="op">,</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>               <span class="dt">float</span> step<span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>ColorBuffer <span class="op">&amp;</span>colors<span class="op">,</span> Pointi spos<span class="op">,</span> Pointf sb_pos<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>reference_wrapper<span class="op">&lt;</span><span class="at">const</span> Triangle<span class="op">&gt;</span> <span class="va">triangle_</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  ColorFn <span class="va">color_fn_</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> <span class="va">init_offset_</span><span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> <span class="va">step_</span><span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally for each sampling point, we compute the barycentric coordinates (<span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span>) with respect to the triangle. Then <span class="math inline">\(c_0 \alpha + c_1 \beta + c_2 \gamma\)</span> gives the color for the sample point where <span class="math inline">\(c_1\)</span>, <span class="math inline">\(c_2\)</span>, and <span class="math inline">\(c_3\)</span> are the colors of the triangle. We see this in the lambda provided to <code>rasterize_triangle_()</code> below.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="va">rasterize_triangle_</span><span class="op">(</span>triangle<span class="op">,</span> <span class="op">[&amp;](</span><span class="dt">float</span> sbx<span class="op">,</span> <span class="dt">float</span> sby<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>alpha<span class="op">,</span> beta<span class="op">,</span> theta<span class="op">]</span> <span class="op">=</span> barycentric_coords<span class="op">(</span>sb_triangle<span class="op">,</span> sbx<span class="op">,</span> sby<span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> alpha <span class="op">*</span> c0 <span class="op">+</span> beta <span class="op">*</span> c1 <span class="op">+</span> theta <span class="op">*</span> c2<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Once this is done for all triangles, we’ve effectively rendered the image at a higher resolution. The last step is to condense the sample buffer into the smaller frame buffer. We do this by<br>
taking the average of all sample buffer points associated with each frame buffer point (pixel). This is done in <code>resolve_framebuffer()</code> and uses a generalized function we wrote, <code>average_region()</code>, which computes the average color for a given rectangle within a <code>ColorBuffer</code> object.</p>
<p>The effect of all this, referred to as <em>supersampling</em>, is the reduction of <em>jaggies</em>. In particular, at points that are a combination of multiple colors (e.g., at the border of a triangle), we no longer need to make a discrete decision between one color or another. Instead, through averaging multiple samples, we can provide smooth transitions between colors (antialiasing the triangles).</p>
</section>
<section id="showcase" class="level4">
<h4 class="anchored" data-anchor-id="showcase">Showcase</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task02_s1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption"><code>basic/test4.svg</code> at a sampling rate of 1.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task02_s4.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption"><code>basic/test4.svg</code> at a sampling rate of 4.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task02_s9.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption"><code>basic/test4.svg</code> at a sample rate of 9.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task02_s16.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption"><code>basic/test4.svg</code> at a sample rate of 16.</figcaption><p></p>
</figure>
</div>
<p>As the sample rate increases, the triangle edges become smoother. This is because as the sample rate increases, we are iterating through the buffer frame in smaller steps, then taking the average. This results in the boundary having transitionary colors, reducing <em>jaggies</em>.</p>
</section>
</section>
<section id="part-3-transforms" class="level3">
<h3 class="anchored" data-anchor-id="part-3-transforms">Part 3: Transforms</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task3.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">Here we’ve posed the cubeman in a dancing position.</figcaption><p></p>
</figure>
</div>
<section id="extra-credit-additional-gui-controls" class="level4">
<h4 class="anchored" data-anchor-id="extra-credit-additional-gui-controls">Extra Credit: Additional GUI Controls</h4>
<p>We added 10 additional keyboard controls, which are listed below.</p>
<table class="table">
<thead>
<tr class="header">
<th>Key</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>←</code></td>
<td>Rotate image by -1.0 degree.</td>
</tr>
<tr class="even">
<td><code>→</code></td>
<td>Rotate image by 1.0 degree.</td>
</tr>
<tr class="odd">
<td><code>↑</code></td>
<td>Scale image by 10%.</td>
</tr>
<tr class="even">
<td><code>↓</code></td>
<td>Scale image by -10%.</td>
</tr>
<tr class="odd">
<td><code>R</code></td>
<td>Move image up by 5 pixels.</td>
</tr>
<tr class="even">
<td><code>F</code></td>
<td>Move image down by 5 pixels.</td>
</tr>
<tr class="odd">
<td><code>D</code></td>
<td>Move image left by 5 pixels.</td>
</tr>
<tr class="even">
<td><code>G</code></td>
<td>Move image right by 5 pixels</td>
</tr>
<tr class="odd">
<td><code>U</code></td>
<td>Undo the most recent transformation.</td>
</tr>
<tr class="even">
<td><code>X</code></td>
<td>Reset all transformations.</td>
</tr>
</tbody>
</table>
<p>To do this, we kept a <em>list</em> of transformations produced by the user. Each transformation was abstracted into a class, <code>Transform</code>, which held the arguments and type (stored implicitly as a non-type template parameter to the function pointer). Its definition is below.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">auto</span> TransformFn<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span> <span class="kw">class</span> Transform <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  Transform<span class="op">(</span>Args<span class="op">...</span> args<span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Invoke the transformation. */</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>apply<span class="op">(</span>TransformFn<span class="op">,</span> <span class="va">args_</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>tuple<span class="op">&lt;</span>Args<span class="op">...&gt;</span> <span class="va">args_</span><span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We then created convenient aliases for each transformation type (translate, scale, rotate), and formed a <code>std::variant</code> (type-safe union) of these types. This type, <code>TransformVariant</code>, is the type stored in the list of transformations.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> TranslateTransform <span class="op">=</span> Transform<span class="op">&lt;&amp;</span>CGL<span class="op">::</span>translate<span class="op">,</span> <span class="dt">float</span><span class="op">,</span> <span class="dt">float</span><span class="op">&gt;;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ScaleTransform <span class="op">=</span> Transform<span class="op">&lt;&amp;</span>CGL<span class="op">::</span>scale<span class="op">,</span> <span class="dt">float</span><span class="op">,</span> <span class="dt">float</span><span class="op">&gt;;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> RotateTransform <span class="op">=</span> Transform<span class="op">&lt;&amp;</span>CGL<span class="op">::</span>rotate<span class="op">,</span> <span class="dt">float</span><span class="op">&gt;;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> TransformVariant <span class="op">=</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>variant<span class="op">&lt;</span>TranslateTransform<span class="op">,</span> ScaleTransform<span class="op">,</span> RotateTransform<span class="op">&gt;;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The list of transformations is stored in the class <code>TransformSet</code>, which supports adding transformations, undoing transformations, and resetting (removing) all transformations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TransformSet <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="dt">void</span> translate<span class="op">(</span><span class="dt">float</span> fx<span class="op">,</span> <span class="dt">float</span> fy<span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="dt">void</span> scale<span class="op">(</span><span class="dt">float</span> sx<span class="op">,</span> <span class="dt">float</span> sy<span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="dt">void</span> rotate<span class="op">(</span><span class="dt">float</span> deg<span class="op">);</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Undo the most recent transformation, if any. */</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="dt">void</span> undo<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Remove all transformations. */</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="dt">void</span> reset<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Get the result of multiplying all received transformations. */</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> Matrix3x3 get<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* Excluded for brevity. */</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>An instance of <code>TransformSet</code>, <code>transform_set</code>, was added as a member variable to <code>DrawRend</code>. To apply the transformations to the image, we simply multiplied the existing tranformation used in <code>DrawRend::redraw()</code> by <code>transform_set.get()</code>, as below<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> transform <span class="op">=</span> ndc_to_screen <span class="op">*</span> svg_to_ndc<span class="op">[</span>current_svg<span class="op">]</span> <span class="op">*</span> transform_set<span class="op">.</span>get<span class="op">();</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Lastly, we modified <code>DrawRend::keyboard_event()</code>, calling the appropriate <code>TransformSet</code> member function for each of the keys listed above. Note that after each call, we called <code>DrawRend::redraw()</code> to update the image. We also reset the transformation on an image switch.</p>
<section id="extra-credit---note-on-the-undo-operation" class="level5">
<h5 class="anchored" data-anchor-id="extra-credit---note-on-the-undo-operation">Extra Credit - Note on the Undo Operation</h5>
<p>An opportunity for optimization is found in the <code>TransformSet::undo()</code> function<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, which currently pops the most recent transformation and marks the computed matrix “dirty” so that it is recomputed on the next call to <code>TransformSet::get()</code>. This is currently done by multiplying <em>all existing</em> transformations in the list, a wasteful operation. Instead, we could multiply the transformation matrix by the inverse of the most recent transformation (canceling it out) before popping. Better yet, as we know our transformations are only of three forms, we need not have a generalized (likely slower) inverse function. We could have three specialized functions that quickly return the inverse for a given transformation type.</p>
</section>
<section id="extra-credit---showcase" class="level5">
<h5 class="anchored" data-anchor-id="extra-credit---showcase">Extra Credit - Showcase</h5>
<p>We provided a few screenshots demonstrating the result of the added controls below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rotate_-5_deg.png" class="img-fluid figure-img" style="width:50.0%"></p>
<p></p><figcaption class="figure-caption">The program after the user has rotated the image.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rotate_5_deg.png" class="img-fluid figure-img" style="width:50.0%"></p>
<p></p><figcaption class="figure-caption">The program after the user has rotated the image in the opposite direction.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="scale_-30.png" class="img-fluid figure-img" style="width:50.0%"></p>
<p></p><figcaption class="figure-caption">The program after the user has shrunk the image.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="scale_30.png" class="img-fluid figure-img" style="width:50.0%"></p>
<p></p><figcaption class="figure-caption">The program after the user has enlarged the image.</figcaption><p></p>
</figure>
</div>
</section>
</section>
</section>
</section>
<section id="section-ii-sampling" class="level2">
<h2 class="anchored" data-anchor-id="section-ii-sampling">Section II: Sampling</h2>
<section id="part-4-barycentric-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="part-4-barycentric-coordinates">Part 4: Barycentric coordinates</h3>
<p>Barycentric coordinates provide us with a way to represent points within a triangle. For example, in the image below, the point <span class="math inline">\(V\)</span> can be represented by <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span> where <span class="math inline">\(\alpha Va + \beta Vb + \gamma Vc = V\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task4_1.png" class="img-fluid figure-img" style="width:60.0%"></p>
<p></p><figcaption class="figure-caption">A triangle colored using Barycentric coordinates</figcaption><p></p>
</figure>
</div>
<p>We can think of Barycentric coordinates as being akin to three weighted masses at each of the triangle points such that their center of gravity is the point inside the triangle. This provides us with a general mechanism by which we can handle forces or influences at each of the three points of a triangle (and importantly interpolate between them). In our case, these “forces” are simply colors. But we can extend this to more sophisticated use cases, including in the use of textures.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task4_2.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">basic/test4.svg at sample rate 1</figcaption><p></p>
</figure>
</div>
</section>
<section id="part-5-pixel-sampling-for-texture-mapping" class="level3">
<h3 class="anchored" data-anchor-id="part-5-pixel-sampling-for-texture-mapping">Part 5: “Pixel sampling” for texture mapping</h3>
<p>Sampling is the process of getting a value for a pixel from a function, a map, an image, etc. In this case, we are coloring our object based on a given texture mapping. Specifically, given an <span class="math inline">\((x,y)\)</span> coordinate in our object, we translate it to a <span class="math inline">\((u,v)\)</span> coordinate in our texture mapping to get the value we need. To implement this, we use first convert the <span class="math inline">\((x,y)\)</span> coordinate to Barycentric coordinates, and then convert it to the <span class="math inline">\((u,v)\)</span> coordinate, which is what we used to retrieve the value we want. Finally, we set the color at <span class="math inline">\((x,y)\)</span> to be this value. However, it might not be the case that <span class="math inline">\((u,v)\)</span> corresponds exactly to a sample location. That’s why we have two different pixel sampling methods, nearest and bilinear. For nearest pixel sampling, we find the closest sample location to our <span class="math inline">\((u,v)\)</span> and return the value at that location. For bilinear pixel sampling, we do a bilinear interpolation of the values at the four closest sample locations and return the result.</p>
<p>Using the pixel inspector, we see an obvious difference in the presence of <em>jaggies</em> between <em>nearest</em> pixel sampling and <em>bilinear</em> pixel sampling. Notice how nearest pixel sampling has obvious blocks of distinct colors neighboring each other, while bilinear pixel sampling provides smoother transitions between colors.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./nearest_task05_cmp.png" class="img-fluid figure-img" style="width:50.0%"></p>
<p></p><figcaption class="figure-caption">Nearest pixel sampling at a rate of 4.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./bilinear_task05_cmp.png" class="img-fluid figure-img" style="width:50.0%"></p>
<p></p><figcaption class="figure-caption">Bilinear pixel sampling at a rate of 4.</figcaption><p></p>
</figure>
</div>
<p>Below we provide a more extreme case – a single line – to make clear the behavior (and benefits) of bilinear sampling. We see at a sampling rate of 1 that nearest pixel sampling has a distinct point at which the line starts and ends, i.e., it is distinctly red or blue, with no in-between, while bilinear sampling has a clear transitionary color. When the sampling rate increases, though, the benefits of bilinear sampling become more subtle.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task5_nearest_1.png" class="img-fluid figure-img" style="width:30.0%"></p>
<p></p><figcaption class="figure-caption">texmap/test1.svg with nearest pixel sampling, sample rate = 1</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task5_bilinear_1.png" class="img-fluid figure-img" style="width:30.0%"></p>
<p></p><figcaption class="figure-caption">texmap/test1.svg with bilinear pixel sampling, sample rate = 1</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task5_nearest_16.png" class="img-fluid figure-img" style="width:30.0%"></p>
<p></p><figcaption class="figure-caption">texmap/test1.svg with nearest pixel sampling, sample rate = 16</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task5_bilinear_16.png" class="img-fluid figure-img" style="width:30.0%"></p>
<p></p><figcaption class="figure-caption">texmap/test1.svg with bilinear pixel sampling, sample rate = 16</figcaption><p></p>
</figure>
</div>
<p>When the sample rate is fixed, bilinear pixel sampling gives better quality as it reduces jaggedness. When the pixel sampling method is fixed, supersampling gives better quality as mentioned in Part 2.</p>
<p>If the texture mapping has low resolution, nearest pixel sampling, and bilinear pixel sampling would look relatively similar since the bilinear interpolation of the four closest sample points to our coordinate will generate the same value as the closest sample point to our coordinate. On the other hand, if the texture mapping has high resolution, there will be a larger difference.</p>
</section>
<section id="part-6-level-sampling-with-mipmaps-for-texture-mapping" class="level3">
<h3 class="anchored" data-anchor-id="part-6-level-sampling-with-mipmaps-for-texture-mapping">Part 6: “Level sampling” with mipmaps for texture mapping</h3>
<p>Level sampling provides maps (textures) of different resolutions to choose from. At a high level, we choose a map based on whether we need to <em>minify</em> or <em>magnify</em> the texture (i.e., make it smaller or larger than its actual size, respectively). The largest texture is the original texture itself, while each after is a simplified, smaller version of the previous. This has various benefits, including saving computation time (we can sample from smaller textures in many cases), and preventing Moiré patterns. Though we typically don’t simply <em>choose</em> a map; doing so would make it obvious to the viewer when we switch from one level to the next. For this reason, we choose the two nearest levels and interpolate between them. The calculation for this level was based on the formula given in <a href="https://cs184.eecs.berkeley.edu/sp23/lecture/5/texture-mapping">Lecture 5</a> and further verified in the <a href="https://cs184.eecs.berkeley.edu/sp23/lecture/5/texture-mapping">OpenGL 4.5 specification</a>. It is given below.</p>
<p><span class="math display">\[\log_2 \left(\max\left(\sqrt{\left(\frac{du}{dx}\right)^2 + \left(\frac{dv}{dx}\right)^2}, \sqrt{\left(\frac{du}{dy}\right)^2 + \left(\frac{dv}{dy}\right)^2}\right)\right)\]</span></p>
<p>The derivatives used in the calculation were obtained by making small increments in the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> directions and taking the resulting change in <span class="math inline">\((u, v)\)</span> coordinates. The approach used to turn the result of the above computation into a usable level differed based on the level sampling approach used. For example, we simply rounded when using the <em>nearest level</em> approach, but linearly interpolated between the <em>nearest two levels</em> when using the <em>bilinear or trilinear level</em> approaches. From here, we used one of the sampling methods as described in Part 5. For <em>nearest level</em>, we simply took the sample at that level; for <em>bilinear or trilinear level</em>, we took the weighted sum of the result of sampling at the two nearest levels. One important implementation detail was the need to to clamp the level between 0 and the maximum level. This matched our intuition and was confirmed by the OpenGL specification.</p>
<section id="tradeoffs-between-speed-memory-usage-and-antialiasing-power-between-the-three-various-techniques" class="level4">
<h4 class="anchored" data-anchor-id="tradeoffs-between-speed-memory-usage-and-antialiasing-power-between-the-three-various-techniques">Tradeoffs between speed, memory usage, and antialiasing power between the three various techniques:</h4>
<section id="speed-pixel-sampling-level-sampling-supersampling" class="level5">
<h5 class="anchored" data-anchor-id="speed-pixel-sampling-level-sampling-supersampling">Speed: Pixel Sampling <span class="math inline">\(&gt;\)</span> Level Sampling <span class="math inline">\(&gt;\)</span> Supersampling</h5>
<p>Pixel sampling only performs some calculations at the sampling points near the coordinate, so it should be the most performant. Level sampling needs to additionally find the level of mapping to use, so it will be slower than pixel sampling. Finally, supersampling would be the slowest as it could go all the way up to a sample rate of 16 in our case, and even higher in the industry, requiring significant amounts of computation per pixel</p>
</section>
<section id="memory-usage-supersampling-level-sampling-pixel-sampling" class="level5">
<h5 class="anchored" data-anchor-id="memory-usage-supersampling-level-sampling-pixel-sampling">Memory usage: Supersampling <span class="math inline">\(&gt;\)</span> Level Sampling <span class="math inline">\(&gt;\)</span> Pixel Sampling</h5>
<p>Pixel sampling only performs some calculations at the sampling points near the coordinate, so it doesn’t use too much memory. Level sampling needs to additionally find the level of mapping to use, so it will need more memory to store all maps of different levels. More specifically, it requires an additional one third of memory for each texture. Finally, supersampling would cost the most in terms of memory since it could go all the way up to a sample rate of 16 in our case, and even higher in the industry, which requires us to store information at up to 16 times more points.</p>
</section>
<section id="antialiasing-power-supersampling-level-sampling-pixel-sampling" class="level5">
<h5 class="anchored" data-anchor-id="antialiasing-power-supersampling-level-sampling-pixel-sampling">Antialiasing power: Supersampling <span class="math inline">\(&gt;\)</span> Level Sampling <span class="math inline">\(&gt;\)</span> Pixel Sampling</h5>
<p>Since we are theoretically not limited in our choice of sampling rate, super sampling provides a direct trade off between antialiasing power and speed/memory usage. This makes it the most powerful approach in this regard. It is followed by level sampling, which is stronger than pixel sampling due to its ability to make various improvements to image quality, including the prevention of Moiré patterns.</p>
</section>
<section id="rendering-result-1" class="level5">
<h5 class="anchored" data-anchor-id="rendering-result-1">Rendering Result</h5>
<p>We showcase the difference between the methods below. Notice the electrical lines as that is where the difference is most distinct. The pixel inspector is focused on the top of the left-most tree. We observe far less <em>jaggies</em> using bilinear sampling across both level methods.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task06_l0_nearest.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption"><code>texmap/my_test.svg</code> with level 0, nearest pixel sampling.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task06_l0_bilinear.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption"><code>texmap/my_test.svg</code> with level 0, bilinear pixel sampling.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task06_lnearest_nearest.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption"><code>texmap/my_test.svg</code> with nearest level, nearest pixel sampling.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="task06_lnearest_bilinear.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption"><code>texmap/my_test.svg</code> with nearest level, bilinear pixel sampling.</figcaption><p></p>
</figure>
</div>
</section>
</section>
<section id="extra-credit-summed-area-tables" class="level4">
<h4 class="anchored" data-anchor-id="extra-credit-summed-area-tables">Extra Credit: Summed Area Tables</h4>
<p>We implemented summed area tables as an alternative sampling method based on the <a href="https://dl.acm.org/doi/pdf/10.1145/800031.808600">paper</a> by Franklin Crow from 1984. We compare the results of the different methods below. All results were obtained at pixel sampling rate of 4.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./nearest.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">Nearest Pixel Sampling</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./bilinear.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">Bilinear Pixel Sampling</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./trilinear.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">Trilinear Pixel Sampling</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./sat.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">Summed Area Table Sampling</figcaption><p></p>
</figure>
</div>
<p>We observe that Summed Area Table sampling seems to produce a <em>crisper</em> image compared to the others at this sampling rate<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. However, on careful inspection one can notice a rough textural pattern on the ocean (almost as if it was painted on a canvas) that is not present on the other images. This is present regardless of the sampling rate. We were unable to pinpoint the cause of this issue, but it is likely due to a subtle flaw in our implementation (rather than a a flaw of Summed Area Tables). For example, it could be related to how we calculate the bounding box on the texture associated with a pixel.</p>
</section>
<section id="extra-credit-summed-area-tables---performance-comparison" class="level4">
<h4 class="anchored" data-anchor-id="extra-credit-summed-area-tables---performance-comparison">Extra Credit: Summed Area Tables - Performance Comparison</h4>
<p>For the following comparison, we tested only the time taken to draw the SVG. In particular, we only timed the duration of the call to <code>SVG::draw()</code> in <code>DrawRend::redraw()</code>. The results are listed below. We see that the cost of greater memory usage (via the summed area table) provides signficant performance gains. It sits between nearest and bilinear in performance while providing higher image quality (discarding the subtle distoration due to our implementation flaw).</p>
<table class="table">
<thead>
<tr class="header">
<th>Method</th>
<th>Sampling Rate (per pixel)</th>
<th>Time Elapsed (seconds)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nearest</td>
<td>1</td>
<td>0.00706412</td>
</tr>
<tr class="even">
<td>Bilinear</td>
<td>1</td>
<td>0.00842444</td>
</tr>
<tr class="odd">
<td>Trilinear</td>
<td>1</td>
<td>0.0172887</td>
</tr>
<tr class="even">
<td>SAT</td>
<td>1</td>
<td>0.00804278</td>
</tr>
<tr class="odd">
<td>Nearest</td>
<td>4</td>
<td>0.0211001</td>
</tr>
<tr class="even">
<td>Bilinear</td>
<td>4</td>
<td>0.0297334</td>
</tr>
<tr class="odd">
<td>Trilinear</td>
<td>4</td>
<td>0.0609966</td>
</tr>
<tr class="even">
<td>SAT</td>
<td>4</td>
<td>0.0256646</td>
</tr>
<tr class="odd">
<td>Nearest</td>
<td>9</td>
<td>0.0472816</td>
</tr>
<tr class="even">
<td>Bilinear</td>
<td>9</td>
<td>0.0658713</td>
</tr>
<tr class="odd">
<td>Trilinear</td>
<td>9</td>
<td>0.136995</td>
</tr>
<tr class="even">
<td>SAT</td>
<td>9</td>
<td>0.0548723</td>
</tr>
<tr class="odd">
<td>Nearest</td>
<td>16</td>
<td>0.079494</td>
</tr>
<tr class="even">
<td>Bilinear</td>
<td>16</td>
<td>0.114779</td>
</tr>
<tr class="odd">
<td>Trilinear</td>
<td>16</td>
<td>0.201299</td>
</tr>
<tr class="even">
<td>SAT</td>
<td>16</td>
<td>0.0880523</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>We saved the transformation, used various times throughout the function, in <code>transform</code>; the original function recomputed the transformation on each use.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Though this may add unneeded complexity. We did not observe input delays when undoing after adding many transformations.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>If this isn’t obvious, pay attention to the dark green patch in the center of Africa. There is far more nuance in the Summed Area Table rendering compared with the others.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>